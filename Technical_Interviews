**Autentication**

ğŸ‘‰ Below is a working, end-to-end explanation of how Java Spring Boot + JWT + Amazon Cognito + API Gateway + Authorizer integrate in a real production-style flow, using your API Gateway setup as context.

Iâ€™ll keep this practical and implementation-focused, not just theory.

User / Client
   |
   | 1. Login (username/password)
   v
Amazon Cognito User Pool
   |
   | 2. JWT Tokens (Access, ID, Refresh)
   v
Client (stores tokens)
   |
   | 3. API call with Authorization: Bearer <AccessToken>
   v
API Gateway
   |
   | 4. Cognito Authorizer
   |    - Validate signature
   |    - Validate exp
   |    - Validate issuer
   v
ALB (via VPC Link)
   |
   | 5. Forward headers + claims
   v
Spring Boot App
   |
   | 6. Business logic
   v
Response

2ï¸âƒ£ Cognito â€“ Token Generation (How JWT is Created)

ğŸ”¹ Login Flow

Your client calls Cognito:
ğŸ‘‰ POST https://cognito-idp.<region>.amazonaws.com/
With:
InitiateAuth, USERNAME/PASSWORD ,ClientId

ğŸ”¹ Cognito returns 3 tokens:
Token	Purpose
ID Token	User identity (used by frontend)
Access Token	Authorization (used for APIs)
Refresh Token	Get new tokens without re-login

ğŸ”¹ JWT Structure

All Cognito tokens are JWTs:
header.payload.signature

Decoded payload example:

{
  "sub": "uuid",
  "iss": "https://cognito-idp.ca-central-1.amazonaws.com/ca-central-1_XXXX",
  "client_id": "abcd1234",
  "token_use": "access",
  "scope": "openid profile",
  "exp": 1715000000,
  "username": "john.doe"
}


âœ” Signed using RS256
âœ” Public keys available via JWKS endpoint

ğŸ‘‰ https://cognito-idp.ca-central-1.amazonaws.com/<userPoolId>/.well-known/jwks.json

3ï¸âƒ£ Client â†’ API Gateway (How Token Is Sent)

Client calls your API:
PUT /user/123/attributes
With header:
Authorization: Bearer eyJraWQiOiJLT...

4ï¸âƒ£ API Gateway + Authorizer (Token Validation)

ğŸ‘‰ You typically use Cognito User Pool Authorizer (recommended).

ğŸ”¹ What the Authorizer Does Automatically

When request hits API Gateway:

Extracts token from:

Authorization: Bearer <JWT>

Verifies:

Token signature (using Cognito public key)
Token expiration (exp)
Issuer (iss)
Token type (token_use = access)
Audience / client id

If valid â†’ request proceeds

If invalid â†’ 401 Unauthorized (Lambda not called)

6ï¸âƒ£ Spring Boot â€“ Token Validation (Two Approaches)
ğŸ”¹ Approach 1 (Best Practice)

ğŸ‘‰ API Gateway validates token
ğŸ‘‰ Spring Boot only reads claims

In Spring Boot
Claims arrive as HTTP headers:

x-amzn-oidc-data
x-amzn-oidc-identity

Or forwarded as:
X-User-Id
X-Username

ğŸ‘‰ No JWT validation needed in app.
------------------------------------------------------------------------------------------------------------------------------------------------------

ğŸ‘‰ HTTP API + VPC Link â†’ NLB only

**REST API:**

Cognito Authorizer
Custom Lambda Authorizer
API keys + usage plans
Request validation
Resource policies
Transform headers
Modify payloads
Validate schemas
Block invalid requests before backend

**HTTP API:**

Cognito Authorizer
JWT Authorizer
IAM auth
âŒ No custom Lambda authorizer logic (classic)
Pass-through only
Backend must handle everything

9ï¸âƒ£ Migration Consideration

âŒ REST â†’ HTTP is NOT trivial if you use:

Mapping templates
Usage plans
ALB with VPC Link
Custom authorizers


ğŸ§© How This Ties into Spring Security Filter Chain (JWT Token validation at Spring Boot)
HTTP Request
   â†“
AwsCognitoJwtAuthenticationFilter  â† extracts JWT (OncePerRequestFilter) --> calls method protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
   â†“
CognitoJwtAuthenticationProvider   â† invokes processor
   â†“
ConfigurableJWTProcessor           â† validates JWT (Nimbus) 
   jwtClaimsSet = configurableJWTProcessor.process(idToken, null);
   String username = jwtClaimsSet.getClaims().get(jwtConfiguration.getUserNameField()).toString();
	 claimSetUserMap.put(username, jwtClaimsSet);
	 isIssuedCorrectly(jwtClaimsSet, jwtConfiguration.getCognitoIdentityPoolUrl());
   â†“
SecurityContextHolder              â† authenticated

If validation fails:
401 Unauthorized

ğŸ‘‰ access_token exmaple:
{
  "sub": "81e039a5-357b-43c1-88ad-1e8afe887b92",
  "event_id": "f1322268-10c5-4836-ac84-fe032a003ef9",
  "token_use": "access",
  "scope": "aws.cognito.signin.user.admin",
  "auth_time": 1768814027,
  "iss": "https://cognito-idp.ca-central-1.amazonaws.com/ca-central-1_ppqL98N2N",
  "exp": 1768817627,
  "iat": 1768814027,
  "jti": "12edfde5-715d-4ca4-b273-f850d65d3f01",
  "client_id": "5flqb7foprr9emnv6lk33crsg2",
  "username": "papuldas"
}

ğŸ”„ Real Refresh Flow (Exact)
Client â†’ /renewToken
   â†“
Spring Security Context (ID token)
   â†“
Send ID token to **/saml2/renewToken**
   â†“
Auth service:
   â”œâ”€ validates ID token
   â”œâ”€ extracts user / sub
   â”œâ”€ fetches refresh token from DB
   â”œâ”€ calls Cognito oauth2/token
   â””â”€ returns new tokens

ğŸ‘‰ In My Project (CATS) following is happening
Cognito issues ID tokens, and the Spring Boot application validates those ID tokens locally using a JWT processor (Nimbus), without calling Cognito at runtime.

Cognito User Pool
   â””â”€ Issues ID Token (JWT)
        â†“
Client
   â””â”€ Sends ID Token
        â†“
Spring Boot API
   â””â”€ Validates JWT locally (JWKS)

ğŸ‘‰ For Getting Authorization code

https://ap-south-14opmjtf9v.auth.ap-south-1.amazoncognito.com/oauth2/authorize
?response_type=code
&client_id=5or73icjoef43c1qs75en0ntqn
&redirect_uri=https://d84l1y8p4kdic.cloudfront.net
&scope=openid+email+phone

ğŸ‘‰ Same Code will be passed in below to get JWT token

curl --location 'https://ap-south-14opmjtf9v.auth.ap-south-1.amazoncognito.com/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic NW9yNzNpY2pvZWY0M2MxcXM3NWVuMG50cW46dGJicm1oNzFpNjFrZTdmdG0wcWRwcWZwZjFxYjc2bXBwYWo4M3MzYTBidGphNHBxbzg=' \
--header 'Cookie: XSRF-TOKEN=894b2d01-f6f5-4cab-b388-261193512d5b' \ 
--data-urlencode 'grant_type=authorization_code' \
--data-urlencode 'code=b60ba969-11e9-4f3a-a25a-96520ba15114' \ âœ…
--data-urlencode 'redirect_uri=https://d84l1y8p4kdic.cloudfront.net'  ğŸ§© Must be same as used in /authorize


What Would Happen If Code Were Reusable? âŒ

Imagine this flow if the code could be reused:

User logs in

Cognito redirects with:

?code=ABC123

Your backend exchanges it for tokens âœ…

ğŸ§©Attacker steals the same code (logs, browser history, proxy, network)

Attacker reuses:

code=ABC123


Attacker gets valid access + ID tokens

ğŸ’¥ Full account compromise

Single-use stops step 4 â†’ 6.

OAuth Threat Model (Why It Exists)

OAuth assumes:

Browsers are not fully trusted

URLs can leak via:

Browser history,Referrer headers,Logs,Proxies

Redirect mishandling

So OAuth splits authentication into two steps:

Step	Where
Authorization Code	Browser (unsafe)
Token Exchange	Backend (secure)

ğŸ§© The code is a temporary bridge, not a credential.

How Cognito Enforces This

Internally Cognito:
Stores each authorization code
Marks it as:
Used OR
Expired (~5 minutes)

ğŸ§© When reused: (/token give below response with 400)
{
  "error": "invalid_grant"
}


This is intentional and required by RFC 6749.

Why Tokens CAN Be Reused but Codes Cannot
Item	Reusable?	Why
Authorization Code	âŒ No	Browser-exposed
Access Token	âœ… Yes (until exp)	Signed, scoped
ID Token	âœ… Yes (until exp)	Identity assertion
Refresh Token	âœ… Yes	Stored securely server-side

REST API + Cognito authorizer = ID token âœ…
HTTP API + JWT authorizer = Access token âœ…

---------------------------------------------------------------------------
ğŸ§© CORS

Frontend (Browser)                          API Server
https://frontend.com                        https://api.example.com
       |                                           |
       | ---- OPTIONS /data (preflight) --------->|
       |                                           |
       |<--- 200 OK + Access-Control-Allow-Origin *--|
       |                                           |
       | ---- GET /data (actual request) -------->|
       |                                           |
       |<--- 200 OK + JSON data ------------------|

Step-by-step explanation:

Preflight request (OPTIONS)

Browser asks:
"Can I send a GET/POST with these headers to your API?"

API responds with:

Access-Control-Allow-Origin: https://frontend.com
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Authorization, Content-Type

Actual request (GET/POST)
Browser sends the real request with token/headers.

API responds with the actual data and includes Access-Control-Allow-Origin in response.

Browser allows response

Only if CORS headers match â†’ JS can access response.
If headers missing â†’ browser blocks the response, frontend sees CORS error.

-------------------------------------------------------------------------------------------------------------------

